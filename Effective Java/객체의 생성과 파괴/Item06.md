## 06. 불필요한 객체 생성을 피하라

### 객체의 재사용

- 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 낫다.
- 빠르고 세련되며 특히 불변 객체는 언제든 재사용할 수 있다.



1. 잘못된 사례

```java
String s = new String("hello")
```

- 실행될 때마다 String 인스턴스를 새로 만든다.
- 생성자에 넘겨진 문자열 자체가 이 생성자로 만들어내려는 String과 기능적으로 완전히 똑같다.
- 이 문장이 반복문이나 빈번히 호출되는 메서드 안에 있다면 쓸데없는 인스턴스가 수백개 만들어질 수 있다.

2. 개선된 버전

```java
String s = "hello"
```

- 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다.
- 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다.



### 정적 팩터리 메서드 활용

- 생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.
- 생성자는 호출할 때마다 새로운 객체를 만들지만 팩터리 메서드는 전혀 그렇지 않기 때문이다.
- 불변 객체만이 아니라 가변 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용할 수 있다.



1. 생성 바용이 높은 객체의 잘못된 재사용 사례

```java
static boolean isRomanNumeral(String s){
  return s.matches(정규표현식);
}
```

- String.matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기에는 적합하지 않다.
- 이 메서드 내부에서 만드는 정규표현식용 Pattern 인스턴스는 한번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 된다.
- Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 인스턴스 생성 비용이 높다.



2. 개선된 버전

```java
public class RomanSumerals {
  private static final Pattern ROMAN = Pattern.compile(정규표현식);
  
  static boolean isRomanNumeral(String s){
    return ROMAN.matcher(s).matches();
  }
}
```

- 성능을 개선하려면 Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해두고, 나중에 isRomanNumeral 메서드가 호출될 때마다 이 인스턴스를 재사용 하면 된다.
- 성능을 끌어올리며 개선 전에는 존재조차 몰랐던 인스턴스를 필드로 끄집어내 이름을 지어주며 코드의 의미가 훨씬 잘 드러난다.





### 재사용시 덜 명확하거나 직관에 반대되는 상황

1. 어댑터(view)

- 실제 작업은 뒷단 객체에 위임하고 자신은 제2의 인터페이스 역할을 해주는 객체
- 뒷단 객체만 관리하며 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분하다.
- Map 인터페이스의 keySet 메서드는 Map 객체 안의 키 전부를 담은 Set 뷰를 반환한다.
- keySet을 호출할 때마다 새로 Set 인스턴스가 만들어 질수도 있지만 매번 같은 Set 인스턴스를 반환할지도 모른다.
- 반환된 Set 인스턴스가 일반적으로 가변이더라도 반환된 인스턴스들은 기능적으로 모두 똑같다.
- 모두가 똑같은 Map 인스턴스를 대변하기 때문에 반환한 객체 중 하나를 수정하면 다른 모든 객체가 따라서 바뀐다.
- keySet이 뷰 객체를 여러 개 만들어도 상관은 없지만 그럴 필요가 없다.



2. 오토박싱

- 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술
- 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
- 의미상으로는 별다를 것 없지만 성능에서는 그렇지 않다.

```java
private static long sum(){
  Long sum = 0L;
  for(long i = 0; i <= Integer.MAX_VALUE; i++)
    sum += i;
  
  return sum;
}
```

- sum 변수를 long이 아닌 Long으로 선언해서 불필요한 Long 인스턴스가 2개나 만들어진 사례이다.
- 타입을 long으로만 바꿔주면 성능이 급격히 빨라진다.
- 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의해야 한다.



3. 예외사항

- 객체 생성은 비싸니 피해야 한다로 오해하면 안된다.
- 요즘의 JVM에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않는다.
- 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다.



### 객체 풀(pool)

- 아주 무거운 객체가 아닌 다음에야 단순히 객체 생성을 피하고자 별도의 객체 풀을 만들지 말아야 한다.
- 물론 데이터베이스 연결 같은 경우 생성 비용이 워낙 비싸니 재사용 하는 편이 낫다.
- 하지만 일반적으로는 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다.
- 요즘의 JVM의 가비지 컬렉터는 상당히 잘 최적화되어서 가벼운 객체용을 다룰 때는 직접 만든 객체 풀보다 훨씬 빠르다.



### 방어적 복사

- 방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가, 필요없는 객체를 반복 생성했을때의 피해보다 훨씬 크다.
- 방어적 복사에 실패하면 어제 터져 나올지 모른느 버그와 보안 구멍으로 이어지지만, 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 준다.