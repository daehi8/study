## 08. finalizer와 cleaner 사용을 피하라

### 객체 소멸자

1. finalizer

   - 예측할 수없고 상황에 따라 위험할 수도 있어 일반적으로 불필요하다.
   - 오동작, 낮은 성능, 이식성 문제의 원인이 되기도 한다.
   - 나름의 쓰임새가 몇가지 있지만 기본적으로 쓰지 말아야 한다.

2. cleaner

   - finalizer 보다는 덜 위험하지만 여전히 예측할 수 없고 느리고 불필요하다.

3. 수행 시점

   - finalizer와 cleaner는 즉시 수행된다는 보장이 없다.
   - 객체에 접근할 수 없게 된 후 실행되기 까지 얼마나 걸릴지 알수 없다.
   -  제때 실행되어야 하는 작업은 절대 할 수 없다.
   - 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸으며, 이는 가비지 컬렉터 구현마다 천차만별이다.

4. 수행 여부

   - 수행 시점 뿐만 아니라 수행 여부조차 보장하지 않는다.
   - 상태를 영구히 수정하는 작업에서는 절대 의존해서는 안된다.

5. finalizer의 예외처리

   - 동작 중 발생한 예외는 무시되며 처리할 작업이 남았더라도 그 순간 종료된다.
   - 잡지 못한 예외 때문에 해당 객체는 마무리가 덜 된 상태로 남을 수 있다.
   - 예외경고 조차 출력하지 않는다.
   - cleaner는 자신의 스레드를 통제하기 때문에 이러한 문제가 발생하지 않는다.

6. 성능 문제

   - 가비지 컬렉터의 효율을 떨어뜨리게 되어 성능이 매우 느려진다.

7. 보안 문제

   - 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.
   - 생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다.
   - 이 finalizer는 정적 필드에서 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하게 막을 수 있다.
   - 일그러진 객체가 만들어지고 나면 이 객체의 메서드를 호출해 애초에는 허용되지 않았을 작업을 수행할 수도 있다.
   - 객체 생성을 막으려면 생성자에서 에외를 던지는 것만으로 충분하지만, finalizer가 있다면 그렇지도 않다.
   - final 클래스들은 그 누구도 하위 클래스를 만들 수 없으니 이 공격에서 안전하다.
   - final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들고 final로 선언해야 한다.

8. 해결 방안

   - AutoCloseable 을 구현하고 클라이언트에서 인스턴스르 다 쓰고 나면 close 메서드를 호출하면 된다.
   - 각 인스턴스는 자신이 닫혔는지를 추적하는 것이 좋다.
   - close 메서드에서 이 객체는 더 이상 유효하지 않음을 필드에 기록하고, 다른 메서드는 이 필드를 검사해서 객체가 닫힌 후에 불럿다면 IllegalStateException을 던지는 것이다.

9. 적절한 쓰임새

   1. 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할
      - 즉시 호출되리라는 보장은 없지만 안 하는 것보다는 낫다.
      - 자바 라이브러리의 일부 클래스는 안전망 역할의 finalizer를 제공한다.
      - FileInputStream, FileOutputStream, ThreadPoolExecutor
   2. 일반 자바 객체가 네이티브 피어와 연결된 객체
      - 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체
      - 네이티브 피어는 자바 객체가 아니니 가비지 컬렉터는 그 존재를 알지 못한다.
      - 자바 피어를 회수 할 때 네이티브 객체까지 회수하지 못한다.
      - 성능 저하를 감당할 수 있고 네이티브 피어가 중요한 자원을 가지고 있지 않을 때에만 해당된다.

   