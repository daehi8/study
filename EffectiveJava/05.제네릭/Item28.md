## 28. 배열보다는 리스트를 사용하라

### 배열과 제네릭 타입의 차이

1. 배열은 공변이다.
   - Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다.
   - 함께 변한다.
2. 제네릭은 불공변이다.
   - 서로 다른 타입 Type1과 Type2가 있을 때 List<Type1>은 List<Type2>의 하위 타입도 아니고 상위 타입도 아니다.
3. 배열은 실체화된다.
   - 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
4. 제네릭은 타입정보가 런타임에는 소거된다.
   - 원소 타입을 컴파일타임에만 검사하며 런타임엔느 알수조차 없다.
   - 소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘으로 자바 5가 제네릭으로 순조롭게 전환될 수 있도록 해줬다.

-   이상의 주요 차이로 인해 배열과 제네릭은 잘 어우러지지 못한다.
-   배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
-   만약 사용하게 된다면 컴파일 시 제네릭 배열 생성 오류를 일으킨다.



### 제네릭 배열을 만들지 못하게 막은 이유

- 배열이 타입 안전하지 않기 때문이다.
- 이를 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 오류가 발생할 수 있다.
- 런타임에 오류를 막아주겠다는 제네릭 타입 시스템의 취지에 어긋나는 것이다.



### 실체화 불가 타입

- E, List<E>, List<String> 같은 타입을 실체화 불가 타입이라고 한다.
- 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다.
- 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화 될 수 있는 타입은 List<?>와 MAP<?,?>와 같은 비한정적 와일드카드 타입뿐이다.
- 배열을 비한정적 와일드카드 타입으로 만들 수는 있지만 유용하게 쓰일 일은 거의 없다.



### 배열과 제네릭 대처방법

- 제네릭 컬렉션에선느 자신의 원소 타입을 담은 배열을 반환하는 것은 보통 불가능하다.(Item33에서 설명)
- 제네릭 타입과 가변인수 메서드를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 되는 경우는 @SafeVarargs 애너테이션으로 대처할 수 있다.
- 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분은 배열인 E[] 대신 컬렉션인 List<E>를 사용하면 해결된다.



### 핵심

- 배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
- 배열은 공변이고 실체화되는 반면 제네릭은 불공변이고 타입 정보가 소거된다.
- 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않다.
- 제네릭은 런타임에는 타입안전하지 않지만 컴파일타임에는 타입안전하다.
- 둘을 섞어 사용하다가 컴파일 오류나 경고를 만나면 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보는 것이 좋다.