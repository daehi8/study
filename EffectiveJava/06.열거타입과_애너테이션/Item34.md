### 34. Int 상수 대신 열거 타입을 사용하라

### 열거 타입 정의

- 일정 개수의 상수 값을 정의한 다음 그 외의 값은 허용하지 않는 타입



### 정수 열거 패턴

- 타입 안전을 보장할 방법이 없으며 표현력도 좋지 않다.
- 평범한 상수를 나열한 것뿐이라 컴파일하면 그 값이 클라이언트 파일에 그대로 새겨지기 때문에 다시 컴파일해야 한다.
- 정수 상수는 문자열로 출력하기가 다소 까다롭다.
- 정수 대신 문자열 상수를 사용하는 변형 패턴도 있지만 이 변형은 더 나쁘다.



### 열거 타입

```java
public enum Apple { FUJI, PIPPN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }
```

- 열거 타입 자체는 클래스이며 상수 하나당 자신의 인스턴스를 하나씩만들어 public static final 필드로 공개한다.
- 열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 finaldlek.
- 클라이언트가 인스턴스를 직접 생성하거나 확장할 수 없으니 열거 타입 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재함이 보장된다.
- 열거타입은 인스턴스 통제된다.
- 싱글턴은 우너소가 하나뿐인 열거 타입이라 할 수 있고, 열거 타입은 싱글턴을 일반화한 형태라고 볼 수 있다.
- 컴파일타임 타입 안정성을 제공한다.
- 각자의 이름공간이 있어서 이름이 같은상수도 평화롭게 공존한다.
- 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수 도 있다.
- Object 메서드들을 높은 품질로 구현했고, Comparable과 Serializable을 구현했으며 그 직렬화 형태도 구현했다.



### 거대한 열거 타입

- 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.
- 모든 필드는 final이어야 한다.
- 필드는 private으로 두고 별도의 public 접근자 메서드를 두는게 낫다.



### 열거 타입의 정적 메서드

- 자신 안에 정의된 상수들의 값을 배열에 담아 반환한느 정적 메서드인 values를 제공한다.
- 각 열거 타입 값의 toString 메서드는 상수 이름을 문자열로 반환한다.



### 열거 타입의 노출

- 열거 타입을 선언한 클래스 혹은 그 패키지에서만 유용한 기능은 private나 package-private로 구현한다.
- 구현된 열거 탕비 상수는 자신을 선언한 클래스 혹은 패키지에서만 사용할 수 있는 기능을 담게 된다.



### 널리 쓰이는 열거 타입

- 톱레벨 클래스로 만들고 특정 톱레벨 클래스에서만 쓰인다면 해당 클래스의 멤버 클래스로 만든다.



### 상수별 메서드 구현

- 상수별로 다르게 동작하는 코드를 구현하는 더 나은 수단을 제공한다.
- 열거 타입에 apply라는 추상 메서드를 선언하고 각 상수별 클래스 몸체, 즉 각 상수에서 자신에 맞게 재정의하는 방법이다.
- apply가 추상 메서드이므로 재정의하지 않았다면 컴파일 오류로 알려준다.



### 열거 타입을 사용하는 경우

- 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.
- 본질적으로 열거 타입인 타입은 당연히 포함되며, 허용되는 값 모두를 컴파일타임에 이미 알고 있을 때도 쓸 수 있다.
- 열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다.
- 열거 타입은 나중에 상수가 추가돼도 바이너리 수준에서 호환되도록 설계되었다.



### 핵심

- 열거 타입은 확실히 정수 상수보다 뛰어나다.
- 대다수 열거 타입이 명시적 생성자나 메서드 없이 쓰이지만, 각 상수들 특정 데이터와 연결짓거나 상수마다 다르게 동작하게 할 때는 필요하다.
- 드물게는 하나의 메서드가 상수별로 다르게 동작할 때도 있다.
- 이런 열거 타입에서는 switch문 대신 상수별 메서드 구현을 사용하자.
- 열거 타입 상수 일부가 같은동작을 공유한다면 전략 열거 타입 패턴을 사용하자.