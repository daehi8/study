## 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

### 메서드 재정의

- 매서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
- 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.



### Implementation Requirements

- 메서드의 내부 동작 방식을 설명하는 곳
- 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다.



### protected

- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
- 어떤 메서드를 protected로 노출해야 할지는 예측하고 만들어 시험해보는 것이 최선이다.
- protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 적어야 한다.
- 너무 적게 노출해서 상속으로 얻어지는 이점마저 없애지 않도록 주의해야 한다.



### Test

- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는것이 유일한 방법이다.



### 설계

- 널리 쓰일 클래스를 상속용으로 설계한다면 문서화한 내부 사용 패턴과 protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 한다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.



### 제약

- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
- private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다.
- Cloneable과 Serialzable 인터페이스 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다.
- clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
- Serialzable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다.



### 일반 구체 클래스

- 상속용으로 설계하지 않은 클래스는 상속을 금지해야 한다.
- 클래스를 final로 선언하거나 모든 생성자를 private으로 선언하고 public 정적 팩터리를 만들어주는 방법이 있다.
- 핵심 기능을 정의한 인터페이스가 있을 경우 상속을 금지해도 어려움이 없다.
- 래퍼 클래스 패턴 역시 상속 대신 쓸 수 있는 좋은 대안이다.
- 구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지했을 경우 클래스 내부에서 재정의 가능 메서드를 사용하지 않게 만들고 이사실을 문서에 남기는 방법을 사용할 수 있다.
- 각가의 재정의 가능 메서드는 자신의 본문 코드를 private 도우미 메서드로 옮기고 이 도우미 메서드를 호출하도록 수정한 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정하면 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있다.