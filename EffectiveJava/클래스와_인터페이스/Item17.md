## 17. 변경 가능성을 최소화하라

### 불변 클래스

- 인스턴스 내부 값을 수정할 수 없는 클래스
- 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
- 자바 플랫폼 라이브러리의 불변 클래스는 String, 기본 타입의 박싱 클래스, BigInteger, BigDecimal이 있다.
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며 오류가 생길 여지도 적고  훨씬 안전하다.



### 불변 클래스 규칙

1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.



### 불변 객채와 가변객체

- 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간진한다.
- 모든 생성자가 클래스 불변식을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히 불변으로 남는다.
- 가변 객체는 임의의 복잡한 상태에 놓일 수 있다.
- 변경자 메서드가 일으키는 상태 전이를 정밀하게 문서로 남겨놓지 않은 가변 클래스는 믿고 사용하기 어려울 수도 있다.



### 스레드 안전

- 불변 객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다.
- 여러 스레드가 동시에 사용해도 절대 훼손되지 않는다.
- 불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있다.
- 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용해야 한다.
- 가장 쉬운 재활용 방법은 자주 쓰이는 값들을 상수로 제공하는 것이다.



### 정적 팩터리

- 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있다.
- 여러 클라이언트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 줄어든다.
- 새로운 클래스를 설계할 때 public 생성자 대신 정적 팩터리를 만들어두면 클라이언트를 수정하지 않고도 필요에 따라 캐시 기능을 나중에 덧붙일 수 있다.



### 방어적 복사

- 불변 객체를 자유롭게 공유할 수 있다는 점은 방어적 복사도 필요 없다는 뜻이다.
- 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는 것이 좋다.
- String 클래스의 복사 생성자는 이 사실을 잘 이해하지 못한 자바 초창기 때 만들어진 것으로 되도록 사용하지 말아야 한다.



### 객체의 공유

- 불변 객체는 자유롭게 공유할 수 있음은 물론 불변 객체끼리는 내부 데이터를 공유할 수 있다.
- 다른 불변 객체들을 구성요소로 사용할 수 있다.
- 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 복잡해도 불변식을 유지하기 훨씬 수월하기 때문이다.



### 실패 원자성

- 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 한다는 성질이다.
- 불변 객첸느 그 자체로 실패 원자성을 제공한다.
- 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.



### 단점

- 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.
- 값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용을 치러야 한다.
- 원하는 객체를 완성하기까지 단계가 많고 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제가 더 불거진다.



### 생성자 대신 정적 팩터리를 사용한 불변 클래스

```java
pulbic class Complex {
  private final double re;
  private final double im;
  
  private Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }
  
  public static Complex valueOf(double re, double im) {
    return new Complex(re, im);
  }
  
  ...
}
```

- 바깥에서 볼수 없는 package-private 구현 클래스를 원하는 만큼 만들어 활용할 수 있으니 훨씬 유연하다.
- public이나 protected 생성자가 없으니 다른 패키지에서는 이 클래스를 확장하는 게 불가능하기 때문에 패키지 바깥의 클라이언트에서 바라본 이 불변 객체는 사실상 final이다.
- 다수의 구현 클래스를 활용한 유연성을 제공하고 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다.



### BigInteger와 BigDecimal

- 당시엔 불변 객체가 final 이어야 한다는 생각이 널리 퍼지지 않았다.
- 두 클래스의 메서드들은 모두 재정의할 수 있게 설계되었고 하위 호환성이 발목을 잡아 아직 문제가 해결되지 않았다.
- 이 인스턴스를 인수로 받는다면 반드시 확인하고 방어적으로 복사해 사용해야 한다.



### 성능을 위한 완화

- 모든 필드가 final이고 어떤 메서드도 그 객체를 수정할 수 없어야 한다는 규칙은 성능을 위해 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다로 완화할 수 있다.
- 계산 비용이 큰 값을 나중에 계산하여 final이 아닌 필드에 캐시해 똑같은 값을 다시 요청하면 캐시해둔 값을 반환하여 계산 비용을 절감할 수 있다.



### 정리

- 게터가 있다고 무조건 세터를 만들지 말아야 한다.
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
- 불변 클래슨는 장점이 많으며 단점은 특정 상황에서의 잠재적 성능 저하 뿐이다.
- 단순한 값 객체는 항상 불변으로 만들어야 한다.
- String과 BigInteger처럼 무거운 값 객체도 불변으로 만들 수 있는지 고려해야 한다.
- 성능 때문에 어쩔수 없다면 불변 클래스와 쌍을 이루는 갑녀 동반 클래스를 public 클래스로 제공해야 한다.
- 모든 클래스를 불변으로 만들 수는 없다.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄여야 한다.
- 객체의 상태 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
- 꼭 변경해야 할 필드를 뺀 나머지 모둘르 final로 선언해야 한다.
- 다른 합당한 이유가 없다면 모든 필드는 private final 이어야 한다.
- 생성자는 불변식 설정이 모두 완료된 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
- 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.
- 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다.

